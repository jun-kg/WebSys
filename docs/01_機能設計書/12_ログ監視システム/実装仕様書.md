# ログ監視システム実装仕様書

## 1. 実装対象一覧

### 1.1 Phase 1: 基盤実装（優先度：高）

#### 1.1.1 バックエンド実装
| コンポーネント | ファイル | 説明 | 実装内容 |
|----------------|----------|------|----------|
| **ログデータモデル** | `models/Log.ts` | ログエントリの型定義 | TypeScript interfaces |
| **ログAPI** | `routes/logs.ts` | ログ収集・検索API | REST API endpoints |
| **ログサービス** | `services/LogService.ts` | ログ処理ロジック | 収集・フィルタ・統計 |
| **ログミドルウェア** | `middleware/apiLogger.ts` | API アクセス監視 | Express middleware |
| **データベーススキーマ** | `prisma/migrations/` | ログテーブル作成 | PostgreSQL スキーマ |

#### 1.1.2 フロントエンド実装
| コンポーネント | ファイル | 説明 | 実装内容 |
|----------------|----------|------|----------|
| **ログ収集サービス** | `utils/logging/LogService.ts` | ブラウザログ収集 | ログ送信・バッファリング |
| **ログAPI** | `api/logs.ts` | ログAPI呼び出し | Axios ベース |
| **ログ型定義** | `types/log.ts` | ログ関連型定義 | TypeScript types |

### 1.2 Phase 2: 監視ダッシュボード（優先度：高）

#### 1.2.1 ダッシュボード画面
| コンポーネント | ファイル | 説明 | 実装内容 |
|----------------|----------|------|----------|
| **メイン画面** | `views/LogDashboard.vue` | ログ監視画面 | レイアウト・状態管理 |
| **フィルタ** | `components/logs/LogFilters.vue` | 検索・フィルタ | 時間・レベル・カテゴリ |
| **統計表示** | `components/logs/LogStatistics.vue` | ログ統計表示 | 数値・割合表示 |
| **ログ一覧** | `components/logs/LogTable.vue` | ログテーブル | 仮想スクロール・詳細表示 |
| **グラフ表示** | `components/logs/LogCharts.vue` | 時系列グラフ | Chart.js 統合 |

#### 1.2.2 共通コンポーネント
| コンポーネント | ファイル | 説明 | 実装内容 |
|----------------|----------|------|----------|
| **ログレベル表示** | `components/logs/LogLevel.vue` | ログレベル表示 | 色分け・アイコン |
| **ログ詳細** | `components/logs/LogDetail.vue` | ログ詳細モーダル | JSON 表示・コピー |
| **時間選択** | `components/logs/TimeRangePicker.vue` | 時間範囲選択 | プリセット・カスタム |

### 1.3 Phase 3: 分析・アラート（優先度：中）

#### 1.3.1 分析機能
| コンポーネント | ファイル | 説明 | 実装内容 |
|----------------|----------|------|----------|
| **ログ分析** | `services/LogAnalysisService.ts` | ログパターン分析 | 統計・トレンド分析 |
| **レポート生成** | `utils/ReportGenerator.ts` | レポート作成 | PDF・CSV エクスポート |
| **異常検知** | `utils/AnomalyDetector.ts` | 異常パターン検出 | 閾値・機械学習 |

#### 1.3.2 アラート機能
| コンポーネント | ファイル | 説明 | 実装内容 |
|----------------|----------|------|----------|
| **アラートルール** | `models/AlertRule.ts` | アラート設定 | 条件・閾値定義 |
| **アラートサービス** | `services/AlertService.ts` | アラート処理 | 監視・通知 |
| **通知プロバイダ** | `providers/notification/` | 通知送信 | Email・Slack・Webhook |

## 2. 詳細実装仕様

### 2.1 データベーススキーマ

#### 2.1.1 Prisma スキーマ定義
```prisma
// prisma/schema.prisma

model Log {
  id        BigInt   @id @default(autoincrement())
  timestamp DateTime @default(now())
  level     Int
  category  String   @db.VarChar(50)
  message   String

  // 追跡情報
  traceId   String? @db.VarChar(100)
  sessionId String? @db.VarChar(100)
  userId    Int?
  user      User?   @relation(fields: [userId], references: [id])

  // システム情報
  source   String  @db.VarChar(50)
  hostname String? @db.VarChar(255)
  service  String? @db.VarChar(100)

  // 詳細情報
  details         Json?
  errorInfo       Json?
  performanceInfo Json?

  // メタデータ
  tags        String[]
  environment String   @db.VarChar(50) @default("development")

  createdAt DateTime @default(now())

  @@index([timestamp(sort: Desc)])
  @@index([level])
  @@index([category])
  @@index([source])
  @@index([traceId])
  @@index([userId])
  @@index([environment])
  @@map("logs")
}

model LogStatistics {
  id       Int    @id @default(autoincrement())
  date     DateTime @db.Date
  hour     Int?   @db.SmallInt
  level    Int
  category String @db.VarChar(50)
  source   String @db.VarChar(50)
  count    Int    @default(0)

  @@unique([date, hour, level, category, source])
  @@index([date(sort: Desc)])
  @@map("log_statistics")
}

model AlertRule {
  id          Int      @id @default(autoincrement())
  name        String   @db.VarChar(255)
  description String?

  // 条件
  level          Int?
  category       String? @db.VarChar(50)
  source         String? @db.VarChar(50)
  messagePattern String?

  // 閾値
  thresholdCount  Int @default(1)
  thresholdPeriod Int @default(300)

  // 通知設定
  notificationChannels String[]

  isEnabled Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("alert_rules")
}
```

### 2.2 バックエンドAPI実装

#### 2.2.1 ログコントローラ
```typescript
// src/controllers/LogController.ts
import { Request, Response } from 'express'
import { LogService } from '../services/LogService'
import { showError, showSuccess } from '../utils/messages'

export class LogController {
  private logService: LogService

  constructor() {
    this.logService = new LogService()
  }

  // ログ収集
  async collectLogs(req: Request, res: Response) {
    try {
      const { logs } = req.body

      if (!Array.isArray(logs) || logs.length === 0) {
        return res.status(400).json({
          success: false,
          message: 'ログデータが不正です'
        })
      }

      const result = await this.logService.saveLogs(logs)

      res.json({
        success: true,
        received: result.saved,
        errors: result.errors
      })
    } catch (error) {
      console.error('ログ収集エラー:', error)
      res.status(500).json({
        success: false,
        message: 'ログの保存に失敗しました'
      })
    }
  }

  // ログ検索
  async searchLogs(req: Request, res: Response) {
    try {
      const searchParams = {
        startTime: req.query.startTime as string,
        endTime: req.query.endTime as string,
        levels: req.query.levels ? (req.query.levels as string).split(',').map(Number) : undefined,
        categories: req.query.categories ? (req.query.categories as string).split(',') : undefined,
        sources: req.query.sources ? (req.query.sources as string).split(',') : undefined,
        traceId: req.query.traceId as string,
        userId: req.query.userId ? Number(req.query.userId) : undefined,
        query: req.query.query as string,
        page: req.query.page ? Number(req.query.page) : 1,
        pageSize: req.query.pageSize ? Number(req.query.pageSize) : 50,
        sortBy: req.query.sortBy as string || 'timestamp',
        sortOrder: req.query.sortOrder as string || 'desc'
      }

      const result = await this.logService.searchLogs(searchParams)

      res.json(result)
    } catch (error) {
      console.error('ログ検索エラー:', error)
      res.status(500).json({
        success: false,
        message: 'ログの検索に失敗しました'
      })
    }
  }

  // ログ統計
  async getStatistics(req: Request, res: Response) {
    try {
      const statsParams = {
        startTime: req.query.startTime as string,
        endTime: req.query.endTime as string,
        groupBy: req.query.groupBy as string || 'hour',
        categories: req.query.categories ? (req.query.categories as string).split(',') : undefined,
        levels: req.query.levels ? (req.query.levels as string).split(',').map(Number) : undefined
      }

      const statistics = await this.logService.getStatistics(statsParams)

      res.json(statistics)
    } catch (error) {
      console.error('ログ統計エラー:', error)
      res.status(500).json({
        success: false,
        message: '統計の取得に失敗しました'
      })
    }
  }
}
```

#### 2.2.2 ログサービス
```typescript
// src/services/LogService.ts
import { PrismaClient } from '@prisma/client'
import { LogEntry, LogSearchParams, LogSearchResult, LogStatisticsParams } from '../types/log'

export class LogService {
  private prisma: PrismaClient

  constructor() {
    this.prisma = new PrismaClient()
  }

  // ログ保存
  async saveLogs(logs: LogEntry[]): Promise<{ saved: number; errors: string[] }> {
    const errors: string[] = []
    let saved = 0

    for (const log of logs) {
      try {
        await this.prisma.log.create({
          data: {
            timestamp: new Date(log.timestamp),
            level: log.level,
            category: log.category,
            message: log.message,
            traceId: log.traceId,
            sessionId: log.sessionId,
            userId: log.userId,
            source: log.source,
            hostname: log.hostname,
            service: log.service,
            details: log.details,
            errorInfo: log.error,
            performanceInfo: log.performance,
            tags: log.tags || [],
            environment: log.environment
          }
        })
        saved++
      } catch (error) {
        errors.push(`ログ保存エラー: ${error.message}`)
      }
    }

    // 統計情報更新
    if (saved > 0) {
      await this.updateStatistics(logs.filter((_, index) => index < saved))
    }

    return { saved, errors }
  }

  // ログ検索
  async searchLogs(params: LogSearchParams): Promise<LogSearchResult> {
    const where: any = {}

    // 時間範囲フィルタ
    if (params.startTime || params.endTime) {
      where.timestamp = {}
      if (params.startTime) where.timestamp.gte = new Date(params.startTime)
      if (params.endTime) where.timestamp.lte = new Date(params.endTime)
    }

    // レベルフィルタ
    if (params.levels && params.levels.length > 0) {
      where.level = { in: params.levels }
    }

    // カテゴリフィルタ
    if (params.categories && params.categories.length > 0) {
      where.category = { in: params.categories }
    }

    // ソースフィルタ
    if (params.sources && params.sources.length > 0) {
      where.source = { in: params.sources }
    }

    // トレースIDフィルタ
    if (params.traceId) {
      where.traceId = params.traceId
    }

    // ユーザーIDフィルタ
    if (params.userId) {
      where.userId = params.userId
    }

    // フリーテキスト検索
    if (params.query) {
      where.message = { contains: params.query, mode: 'insensitive' }
    }

    // 総件数取得
    const total = await this.prisma.log.count({ where })

    // ページング計算
    const skip = (params.page - 1) * params.pageSize
    const take = params.pageSize

    // ソート設定
    const orderBy = {}
    orderBy[params.sortBy] = params.sortOrder

    // ログ取得
    const logs = await this.prisma.log.findMany({
      where,
      orderBy,
      skip,
      take,
      include: {
        user: {
          select: {
            id: true,
            username: true,
            name: true
          }
        }
      }
    })

    return {
      logs: logs.map(this.formatLogEntry),
      total,
      page: params.page,
      pageSize: params.pageSize,
      hasNext: skip + take < total
    }
  }

  // 統計データ取得
  async getStatistics(params: LogStatisticsParams) {
    const startDate = new Date(params.startTime)
    const endDate = new Date(params.endTime)

    let groupByField: string
    let dateFormat: string

    switch (params.groupBy) {
      case 'hour':
        groupByField = 'hour'
        dateFormat = 'YYYY-MM-DD HH:00'
        break
      case 'day':
        groupByField = 'date'
        dateFormat = 'YYYY-MM-DD'
        break
      case 'category':
        groupByField = 'category'
        break
      case 'level':
        groupByField = 'level'
        break
      default:
        groupByField = 'hour'
    }

    // 統計クエリの実装
    const statistics = await this.prisma.logStatistics.groupBy({
      by: [groupByField],
      where: {
        date: {
          gte: startDate,
          lte: endDate
        },
        ...(params.categories && { category: { in: params.categories } }),
        ...(params.levels && { level: { in: params.levels } })
      },
      _sum: {
        count: true
      }
    })

    const total = statistics.reduce((sum, stat) => sum + (stat._sum.count || 0), 0)

    return {
      statistics: statistics.map(stat => ({
        key: stat[groupByField]?.toString() || 'unknown',
        count: stat._sum.count || 0,
        percentage: total > 0 ? ((stat._sum.count || 0) / total) * 100 : 0
      })),
      total,
      period: {
        start: params.startTime,
        end: params.endTime
      }
    }
  }

  // ログエントリフォーマット
  private formatLogEntry(log: any): LogEntry {
    return {
      id: log.id.toString(),
      timestamp: log.timestamp.toISOString(),
      level: log.level,
      category: log.category,
      message: log.message,
      traceId: log.traceId,
      sessionId: log.sessionId,
      userId: log.userId,
      user: log.user,
      source: log.source,
      hostname: log.hostname,
      service: log.service,
      details: log.details,
      error: log.errorInfo,
      performance: log.performanceInfo,
      tags: log.tags,
      environment: log.environment
    }
  }

  // 統計情報更新
  private async updateStatistics(logs: LogEntry[]) {
    // バッチで統計を更新
    const statsMap = new Map<string, number>()

    for (const log of logs) {
      const date = new Date(log.timestamp)
      const dateStr = date.toISOString().split('T')[0]
      const hour = date.getHours()

      const key = `${dateStr}-${hour}-${log.level}-${log.category}-${log.source}`
      statsMap.set(key, (statsMap.get(key) || 0) + 1)
    }

    for (const [key, count] of statsMap) {
      const [dateStr, hourStr, levelStr, category, source] = key.split('-')

      await this.prisma.logStatistics.upsert({
        where: {
          date_hour_level_category_source: {
            date: new Date(dateStr),
            hour: parseInt(hourStr),
            level: parseInt(levelStr),
            category,
            source
          }
        },
        update: {
          count: {
            increment: count
          }
        },
        create: {
          date: new Date(dateStr),
          hour: parseInt(hourStr),
          level: parseInt(levelStr),
          category,
          source,
          count
        }
      })
    }
  }
}
```

### 2.3 フロントエンド実装

#### 2.3.1 ログ型定義
```typescript
// src/types/log.ts

export type LogLevel = 60 | 50 | 40 | 30 | 20 | 10
export type LogCategory = 'AUTH' | 'API' | 'DB' | 'SEC' | 'SYS' | 'USER' | 'PERF' | 'ERR'
export type LogSource = 'frontend' | 'backend' | 'database' | 'infrastructure'

export interface LogEntry {
  id?: string
  timestamp: string
  level: LogLevel
  category: LogCategory
  message: string

  traceId?: string
  sessionId?: string
  userId?: number
  user?: {
    id: number
    username: string
    name: string
  }

  source: LogSource
  hostname?: string
  service?: string

  details?: Record<string, any>
  error?: ErrorInfo
  performance?: PerformanceInfo

  tags?: string[]
  environment: string
}

export interface ErrorInfo {
  name?: string
  message?: string
  stack?: string
  code?: string | number
}

export interface PerformanceInfo {
  duration?: number
  memoryUsage?: number
  cpuUsage?: number
}

export interface LogSearchParams {
  startTime?: string
  endTime?: string
  levels?: LogLevel[]
  categories?: LogCategory[]
  sources?: LogSource[]
  traceId?: string
  userId?: number
  query?: string
  page: number
  pageSize: number
  sortBy: string
  sortOrder: 'asc' | 'desc'
}

export interface LogSearchResult {
  logs: LogEntry[]
  total: number
  page: number
  pageSize: number
  hasNext: boolean
}

export interface LogStatistics {
  key: string
  count: number
  percentage: number
}

export interface LogStatisticsResult {
  statistics: LogStatistics[]
  total: number
  period: {
    start: string
    end: string
  }
}
```

#### 2.3.2 ログ収集サービス
```typescript
// src/utils/logging/LogService.ts
import { LogEntry, LogLevel, LogCategory, LogSource } from '@/types/log'
import api from '@/api'

export class LogService {
  private static instance: LogService
  private buffer: LogEntry[] = []
  private flushTimer?: number
  private readonly FLUSH_INTERVAL = 5000  // 5秒
  private readonly BUFFER_SIZE = 100

  private constructor() {
    this.startFlushTimer()
    this.setupGlobalHandlers()
  }

  static getInstance(): LogService {
    if (!LogService.instance) {
      LogService.instance = new LogService()
    }
    return LogService.instance
  }

  // ログエントリ追加
  log(
    level: LogLevel,
    category: LogCategory,
    message: string,
    details?: Record<string, any>,
    error?: any
  ) {
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      category,
      message,
      traceId: this.generateTraceId(),
      sessionId: this.getSessionId(),
      userId: this.getCurrentUserId(),
      source: 'frontend' as LogSource,
      hostname: window.location.hostname,
      service: 'websys-frontend',
      details,
      error: error ? this.formatError(error) : undefined,
      tags: this.generateTags(category),
      environment: process.env.NODE_ENV || 'development'
    }

    this.buffer.push(entry)

    // バッファサイズチェック
    if (this.buffer.length >= this.BUFFER_SIZE) {
      this.flush()
    }
  }

  // 便利メソッド
  fatal(category: LogCategory, message: string, details?: any, error?: any) {
    this.log(60, category, message, details, error)
  }

  error(category: LogCategory, message: string, details?: any, error?: any) {
    this.log(50, category, message, details, error)
  }

  warn(category: LogCategory, message: string, details?: any) {
    this.log(40, category, message, details)
  }

  info(category: LogCategory, message: string, details?: any) {
    this.log(30, category, message, details)
  }

  debug(category: LogCategory, message: string, details?: any) {
    this.log(20, category, message, details)
  }

  trace(category: LogCategory, message: string, details?: any) {
    this.log(10, category, message, details)
  }

  // パフォーマンスログ
  performance(action: string, startTime: number, details?: any) {
    const duration = Date.now() - startTime
    this.log(30, 'PERF', `${action} completed`, {
      ...details,
      performance: { duration }
    })
  }

  // ユーザーアクションログ
  userAction(action: string, details?: any) {
    this.log(30, 'USER', `User action: ${action}`, details)
  }

  // バッファフラッシュ
  async flush() {
    if (this.buffer.length === 0) return

    const logs = [...this.buffer]
    this.buffer = []

    try {
      await api.post('/api/logs', { logs })
    } catch (error) {
      console.error('ログ送信エラー:', error)

      // エラー時はバッファに戻す（ただし無限ループを避ける）
      if (this.buffer.length < this.BUFFER_SIZE * 2) {
        this.buffer.unshift(...logs.slice(0, this.BUFFER_SIZE))
      }
    }
  }

  // タイマー開始
  private startFlushTimer() {
    this.flushTimer = window.setInterval(() => {
      this.flush()
    }, this.FLUSH_INTERVAL)
  }

  // グローバルエラーハンドリング
  private setupGlobalHandlers() {
    // 未処理エラー
    window.addEventListener('error', (event) => {
      this.error('ERR', 'Uncaught error', {
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno
      }, event.error)
    })

    // Promise reject
    window.addEventListener('unhandledrejection', (event) => {
      this.error('ERR', 'Unhandled promise rejection', {
        reason: event.reason
      })
    })

    // ページ離脱時にフラッシュ
    window.addEventListener('beforeunload', () => {
      this.flush()
    })
  }

  // ユーティリティメソッド
  private generateTraceId(): string {
    return `trace_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  private getSessionId(): string | undefined {
    return sessionStorage.getItem('sessionId') || undefined
  }

  private getCurrentUserId(): number | undefined {
    // Pinia store から取得
    const authStore = useAuthStore()
    return authStore.user?.id
  }

  private formatError(error: any) {
    if (error instanceof Error) {
      return {
        name: error.name,
        message: error.message,
        stack: error.stack
      }
    }
    return { message: String(error) }
  }

  private generateTags(category: LogCategory): string[] {
    const tags = ['webapp']

    if (category === 'AUTH') tags.push('security')
    if (category === 'API') tags.push('network')
    if (category === 'PERF') tags.push('performance')

    return tags
  }

  // クリーンアップ
  destroy() {
    if (this.flushTimer) {
      clearInterval(this.flushTimer)
    }
    this.flush()
  }
}

// エクスポート用インスタンス
export const logger = LogService.getInstance()

// 便利関数
export const logError = (message: string, details?: any, error?: any) =>
  logger.error('ERR', message, details, error)

export const logInfo = (message: string, details?: any) =>
  logger.info('USER', message, details)

export const logPerformance = (action: string, startTime: number, details?: any) =>
  logger.performance(action, startTime, details)

export const logUserAction = (action: string, details?: any) =>
  logger.userAction(action, details)
```

## 3. 実装優先順位

### 3.1 必須実装（Phase 1）
1. **データベーススキーマ作成**
2. **ログ収集API（バックエンド）**
3. **ログ送信サービス（フロントエンド）**
4. **基本的なログ蓄積機能**

### 3.2 高優先度（Phase 2）
1. **ログ検索API**
2. **ダッシュボード画面**
3. **ログフィルタ機能**
4. **リアルタイム表示**

### 3.3 中優先度（Phase 3）
1. **統計・分析機能**
2. **アラート機能**
3. **レポート生成**
4. **パフォーマンス最適化**

---

**作成日**: 2025年9月20日
**バージョン**: 1.0.0
**次回更新**: Phase 1 完了後