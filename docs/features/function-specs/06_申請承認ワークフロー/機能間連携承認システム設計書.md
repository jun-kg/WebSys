# 機能間連携承認システム設計書

## 1. 概要

既存システムの全機能に対して、必要に応じて承認フローを組み込む統合承認システムを設計します。これにより、企業のガバナンス要件に応じて柔軟な承認制御が可能になります。

## 2. 承認対象機能の分析

### 2.1 既存機能の承認レベル分類

| 機能カテゴリ | 機能名 | 承認レベル | 理由 |
|-------------|---------|------------|------|
| **ユーザー管理** | ユーザー追加 | 必須 | セキュリティ重要 |
| | ユーザー削除 | 必須 | 影響度大 |
| | 権限変更 | 条件付き | 権限昇格時のみ |
| | パスワードリセット | 任意 | 他人の場合のみ |
| **組織管理** | 部署追加/削除 | 必須 | 組織構造変更 |
| | 部署権限変更 | 必須 | 権限影響大 |
| **権限管理** | 権限テンプレート変更 | 条件付き | システムテンプレート時 |
| | 権限マトリクス変更 | 必須 | 全社影響 |
| **システム設定** | 会社情報変更 | 必須 | 基本設定変更 |
| | ログ設定変更 | 条件付き | セキュリティ関連時 |
| **データ操作** | 大量データ削除 | 必須 | データ保護 |
| | データエクスポート | 条件付き | 機密情報時 |

## 3. 承認制御システム設計

### 3.1 承認ポリシー管理テーブル

```sql
-- 承認ポリシー定義テーブル
CREATE TABLE approval_policies (
    id SERIAL PRIMARY KEY,
    feature_code VARCHAR(50) NOT NULL,  -- 機能コード
    action_type VARCHAR(50) NOT NULL,   -- CREATE, UPDATE, DELETE, EXPORT等
    policy_name VARCHAR(100) NOT NULL,
    is_approval_required BOOLEAN DEFAULT false,
    conditions JSON,                     -- 承認が必要な条件
    workflow_type_id INT,               -- 使用するワークフロー
    bypass_roles JSON,                  -- 承認をバイパスできる役割
    company_id INT,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (workflow_type_id) REFERENCES workflow_types(id),
    FOREIGN KEY (company_id) REFERENCES companies(id),
    UNIQUE(company_id, feature_code, action_type)
);

-- インデックス
CREATE INDEX idx_approval_policies_feature ON approval_policies(feature_code, action_type);
CREATE INDEX idx_approval_policies_company ON approval_policies(company_id);
```

### 3.2 承認ポリシー設定例

```json
[
  {
    "feature_code": "USER_MANAGEMENT",
    "action_type": "CREATE",
    "policy_name": "ユーザー追加承認",
    "is_approval_required": true,
    "conditions": {},
    "workflow_type_id": 1,
    "bypass_roles": ["SUPER_ADMIN"]
  },
  {
    "feature_code": "USER_MANAGEMENT",
    "action_type": "UPDATE",
    "policy_name": "ユーザー情報変更承認",
    "is_approval_required": true,
    "conditions": {
      "require_approval_when": [
        {"field": "role", "change_type": "upgrade"},
        {"field": "permissions", "change_type": "expand"}
      ]
    },
    "workflow_type_id": 1,
    "bypass_roles": ["ADMIN"]
  },
  {
    "feature_code": "DEPARTMENT_MANAGEMENT",
    "action_type": "DELETE",
    "policy_name": "部署削除承認",
    "is_approval_required": true,
    "conditions": {
      "require_approval_when": [
        {"field": "has_users", "operator": "greater_than", "value": 0}
      ]
    },
    "workflow_type_id": 2
  },
  {
    "feature_code": "DATA_EXPORT",
    "action_type": "EXPORT",
    "policy_name": "データエクスポート承認",
    "is_approval_required": true,
    "conditions": {
      "require_approval_when": [
        {"field": "data_type", "operator": "in", "value": ["personal_info", "financial"]},
        {"field": "record_count", "operator": "greater_than", "value": 1000}
      ]
    },
    "workflow_type_id": 3
  }
]
```

## 4. 承認制御エンジン

### 4.1 承認判定サービス

```typescript
export class ApprovalPolicyService {

  /**
   * 指定された操作に承認が必要かどうかを判定
   */
  async requiresApproval(
    featureCode: string,
    actionType: string,
    operationData: any,
    currentUser: User,
    companyId: number
  ): Promise<ApprovalRequirement> {

    // 1. 該当する承認ポリシーを取得
    const policy = await prisma.approval_policies.findFirst({
      where: {
        feature_code: featureCode,
        action_type: actionType,
        company_id: companyId,
        is_active: true
      },
      include: {
        workflow_types: true
      }
    });

    if (!policy) {
      return { required: false };
    }

    // 2. バイパス権限チェック
    if (this.canBypassApproval(currentUser, policy.bypass_roles)) {
      return { required: false, reason: 'BYPASSED_BY_ROLE' };
    }

    // 3. 条件ベース判定
    if (!policy.is_approval_required) {
      return { required: false };
    }

    const conditionsMet = await this.evaluateConditions(
      policy.conditions,
      operationData,
      currentUser
    );

    if (!conditionsMet) {
      return { required: false, reason: 'CONDITIONS_NOT_MET' };
    }

    return {
      required: true,
      policy: policy,
      workflowType: policy.workflow_types,
      estimatedDuration: this.estimateApprovalDuration(policy.workflow_type_id)
    };
  }

  /**
   * 条件評価エンジン
   */
  private async evaluateConditions(
    conditions: any,
    operationData: any,
    currentUser: User
  ): Promise<boolean> {

    if (!conditions?.require_approval_when) {
      return true; // 条件未指定の場合は承認必要
    }

    for (const condition of conditions.require_approval_when) {
      if (await this.evaluateSingleCondition(condition, operationData, currentUser)) {
        return true; // いずれかの条件に合致すれば承認必要
      }
    }

    return false;
  }

  /**
   * 単一条件の評価
   */
  private async evaluateSingleCondition(
    condition: any,
    operationData: any,
    currentUser: User
  ): Promise<boolean> {

    const { field, operator, value, change_type } = condition;

    switch (field) {
      case 'role':
        if (change_type === 'upgrade') {
          return this.isRoleUpgrade(operationData.oldRole, operationData.newRole);
        }
        break;

      case 'permissions':
        if (change_type === 'expand') {
          return this.isPermissionExpansion(operationData.oldPermissions, operationData.newPermissions);
        }
        break;

      case 'has_users':
        if (operator === 'greater_than') {
          const userCount = await this.getUserCountInDepartment(operationData.departmentId);
          return userCount > value;
        }
        break;

      case 'data_type':
        if (operator === 'in') {
          return value.includes(operationData.dataType);
        }
        break;

      case 'record_count':
        if (operator === 'greater_than') {
          return operationData.recordCount > value;
        }
        break;

      case 'amount':
        if (operator === 'greater_than') {
          return parseFloat(operationData.amount) > value;
        }
        break;
    }

    return false;
  }
}

interface ApprovalRequirement {
  required: boolean;
  reason?: string;
  policy?: any;
  workflowType?: any;
  estimatedDuration?: number; // 承認完了予想時間（時間）
}
```

## 5. 既存機能への統合

### 5.1 承認統合デコレーター

```typescript
/**
 * 承認制御デコレーター
 */
export function RequiresApproval(featureCode: string, actionType: string) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      const [operationData, currentUser] = args;

      // 1. 承認要否判定
      const requirement = await approvalPolicyService.requiresApproval(
        featureCode,
        actionType,
        operationData,
        currentUser,
        currentUser.companyId
      );

      if (!requirement.required) {
        // 承認不要 - 直接実行
        return await method.apply(this, args);
      }

      // 2. 承認プロセス開始
      const approvalRequest = await this.startApprovalProcess(
        requirement,
        operationData,
        currentUser
      );

      return {
        status: 'PENDING_APPROVAL',
        approvalRequestId: approvalRequest.id,
        message: '承認申請を開始しました',
        estimatedDuration: requirement.estimatedDuration
      };
    };
  };
}

// 使用例
export class UserService {

  @RequiresApproval('USER_MANAGEMENT', 'CREATE')
  async createUser(userData: CreateUserRequest, currentUser: User) {
    // ユーザー作成ロジック
    return await prisma.users.create({
      data: userData
    });
  }

  @RequiresApproval('USER_MANAGEMENT', 'UPDATE')
  async updateUser(userId: number, updateData: UpdateUserRequest, currentUser: User) {
    // ユーザー更新ロジック
    return await prisma.users.update({
      where: { id: userId },
      data: updateData
    });
  }
}
```

### 5.2 承認完了時の自動実行

```typescript
export class ApprovalCompletionService {

  /**
   * 承認完了時に元の操作を実行
   */
  async executeApprovedOperation(approvalRequestId: number): Promise<any> {

    const request = await prisma.workflow_requests.findUnique({
      where: { id: approvalRequestId },
      include: {
        workflow_types: true
      }
    });

    if (!request || request.status !== 'APPROVED') {
      throw new Error('Invalid or unapproved request');
    }

    const { feature_code, action_type } = this.parseWorkflowType(request.workflow_types.code);
    const operationData = request.formData;

    // 元の操作を実行
    switch (feature_code) {
      case 'USER_MANAGEMENT':
        return await this.executeUserManagementOperation(action_type, operationData);

      case 'DEPARTMENT_MANAGEMENT':
        return await this.executeDepartmentOperation(action_type, operationData);

      case 'PERMISSION_MANAGEMENT':
        return await this.executePermissionOperation(action_type, operationData);

      default:
        throw new Error(`Unknown feature code: ${feature_code}`);
    }
  }

  private async executeUserManagementOperation(actionType: string, data: any) {
    switch (actionType) {
      case 'CREATE':
        return await prisma.users.create({
          data: {
            ...data,
            isActive: true,
            approval_status: 'APPROVED'
          }
        });

      case 'UPDATE':
        return await prisma.users.update({
          where: { id: data.userId },
          data: data.updateData
        });

      case 'DELETE':
        return await prisma.users.update({
          where: { id: data.userId },
          data: { isActive: false }
        });
    }
  }
}
```

## 6. 一時操作管理

### 6.1 一時操作テーブル

```sql
-- 承認待ち操作テーブル
CREATE TABLE pending_operations (
    id SERIAL PRIMARY KEY,
    approval_request_id INT NOT NULL,
    operation_type VARCHAR(50) NOT NULL,  -- CREATE, UPDATE, DELETE等
    target_table VARCHAR(50) NOT NULL,
    target_id INT,
    operation_data JSON NOT NULL,        -- 操作データ
    original_data JSON,                  -- 変更前データ（UPDATE/DELETE時）
    scheduled_execution_at TIMESTAMP,    -- 実行予定日時
    executed_at TIMESTAMP,
    execution_result JSON,
    status VARCHAR(20) DEFAULT 'PENDING', -- PENDING, EXECUTED, FAILED, CANCELLED
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (approval_request_id) REFERENCES workflow_requests(id)
);
```

## 7. 設定画面での承認ポリシー管理

### 7.1 承認ポリシー設定UI

```vue
<template>
  <div class="approval-policy-settings">
    <el-card header="承認ポリシー設定">
      <el-table :data="policies" style="width: 100%">
        <el-table-column prop="feature_name" label="機能" />
        <el-table-column prop="action_type" label="操作" />
        <el-table-column label="承認要否">
          <template #default="{ row }">
            <el-switch
              v-model="row.is_approval_required"
              @change="updatePolicy(row)"
            />
          </template>
        </el-table-column>
        <el-table-column label="条件">
          <template #default="{ row }">
            <el-button @click="editConditions(row)">設定</el-button>
          </template>
        </el-table-column>
        <el-table-column label="ワークフロー">
          <template #default="{ row }">
            <el-select v-model="row.workflow_type_id">
              <el-option
                v-for="workflow in workflowTypes"
                :key="workflow.id"
                :label="workflow.name"
                :value="workflow.id"
              />
            </el-select>
          </template>
        </el-table-column>
      </el-table>
    </el-card>

    <!-- 条件設定ダイアログ -->
    <el-dialog v-model="showConditionDialog" title="承認条件設定">
      <approval-condition-editor
        v-model="currentConditions"
        :feature-code="currentPolicy.feature_code"
      />
    </el-dialog>
  </div>
</template>
```

## 8. 承認状況の可視化

### 8.1 承認ダッシュボード

```vue
<template>
  <div class="approval-dashboard">
    <!-- 承認待ち件数サマリー -->
    <el-row :gutter="20">
      <el-col :span="6" v-for="category in approvalSummary" :key="category.name">
        <el-card>
          <div class="summary-item">
            <h3>{{ category.name }}</h3>
            <p class="count">{{ category.pending_count }}</p>
            <p class="avg-time">平均処理時間: {{ category.avg_processing_time }}時間</p>
          </div>
        </el-card>
      </el-col>
    </el-row>

    <!-- 承認待ち一覧 -->
    <el-card header="承認待ち一覧">
      <el-table :data="pendingApprovals">
        <el-table-column prop="request_number" label="申請番号" />
        <el-table-column prop="title" label="申請内容" />
        <el-table-column prop="requester_name" label="申請者" />
        <el-table-column prop="current_step" label="承認段階" />
        <el-table-column prop="submitted_at" label="申請日時" />
        <el-table-column label="操作">
          <template #default="{ row }">
            <el-button @click="approveRequest(row)">承認</el-button>
            <el-button @click="rejectRequest(row)">却下</el-button>
          </template>
        </el-table-column>
      </el-table>
    </el-card>
  </div>
</template>
```

## 9. 高度な承認制御

### 9.1 時間ベース承認

```typescript
// 営業時間外の操作は翌営業日まで自動保留
const timeBasedPolicy = {
  "feature_code": "SYSTEM_MAINTENANCE",
  "conditions": {
    "require_approval_when": [
      {
        "field": "execution_time",
        "operator": "outside_business_hours"
      }
    ],
    "auto_approve_during": "maintenance_window"
  }
};
```

### 9.2 金額ベース段階承認

```typescript
// 金額に応じた段階的承認ルート
const amountBasedApproval = {
  "feature_code": "EXPENSE_APPROVAL",
  "approval_routes": [
    {
      "condition": {"amount": {"less_than": 10000}},
      "steps": [{"approver_type": "MANAGER"}]
    },
    {
      "condition": {"amount": {"between": [10000, 100000]}},
      "steps": [
        {"approver_type": "MANAGER"},
        {"approver_type": "DEPARTMENT_HEAD"}
      ]
    },
    {
      "condition": {"amount": {"greater_than": 100000}},
      "steps": [
        {"approver_type": "MANAGER"},
        {"approver_type": "DEPARTMENT_HEAD"},
        {"approver_type": "FINANCE_DIRECTOR"}
      ]
    }
  ]
};
```

### 9.3 リスクベース承認

```typescript
// リスクレベルに応じた承認制御
const riskBasedPolicy = {
  "feature_code": "DATA_ACCESS",
  "conditions": {
    "require_approval_when": [
      {
        "field": "data_sensitivity",
        "operator": "in",
        "value": ["CONFIDENTIAL", "TOP_SECRET"]
      },
      {
        "field": "access_time",
        "operator": "outside_normal_hours"
      },
      {
        "field": "access_location",
        "operator": "not_in_whitelist"
      }
    ]
  }
};
```

## 10. パフォーマンス最適化

### 10.1 承認ポリシーキャッシュ

```typescript
export class ApprovalPolicyCache {
  private cache = new Map<string, ApprovalPolicy>();
  private readonly TTL = 300000; // 5分

  async getPolicy(companyId: number, featureCode: string, actionType: string): Promise<ApprovalPolicy> {
    const key = `${companyId}:${featureCode}:${actionType}`;

    if (this.cache.has(key)) {
      return this.cache.get(key);
    }

    const policy = await this.loadPolicyFromDB(companyId, featureCode, actionType);
    this.cache.set(key, policy);

    // TTL設定
    setTimeout(() => this.cache.delete(key), this.TTL);

    return policy;
  }
}
```

## 11. 監査とコンプライアンス

### 11.1 承認操作の完全監査

```typescript
export class ApprovalAuditService {

  async logApprovalAction(action: ApprovalAuditLog) {
    await prisma.audit_logs.create({
      data: {
        userId: action.userId,
        action: 'APPROVAL_ACTION',
        targetType: 'WORKFLOW_REQUEST',
        targetId: action.requestId,
        oldPermissions: action.beforeState,
        newPermissions: action.afterState,
        reason: action.reason,
        ipAddress: action.ipAddress,
        userAgent: action.userAgent,
        metadata: {
          approval_action: action.approvalAction,
          step_number: action.stepNumber,
          processing_time: action.processingTime,
          delegation_info: action.delegationInfo
        }
      }
    });
  }
}
```

## 12. まとめ

この機能間連携承認システムにより：

### ✅ 実現可能な機能

1. **柔軟な承認制御**: 機能・操作・条件に応じた承認要否判定
2. **既存機能統合**: デコレーターパターンによる非侵襲的統合
3. **条件ベース承認**: 金額・時間・リスクレベル等による動的制御
4. **段階的承認**: 複雑な承認ルートの設定
5. **自動実行**: 承認完了時の操作自動実行
6. **完全監査**: すべての承認操作の追跡

### 🚀 導入効果

- **ガバナンス強化**: 企業ポリシーに準拠した運用
- **リスク軽減**: 重要操作の事前チェック
- **効率化**: 条件に応じた自動承認
- **透明性**: 承認プロセスの可視化
- **コンプライアンス**: 完全な監査証跡

このシステムにより、企業の成長段階や業界要件に応じて、柔軟かつ厳格な承認制御が実現できます。

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"content": "\u7533\u8acb\u30fb\u627f\u8a8d\u30ef\u30fc\u30af\u30d5\u30ed\u30fc\u6a5f\u80fd\u306e\u8a2d\u8a08", "status": "completed", "activeForm": "\u7533\u8acb\u30fb\u627f\u8a8d\u30ef\u30fc\u30af\u30d5\u30ed\u30fc\u6a5f\u80fd\u3092\u8a2d\u8a08\u4e2d"}, {"content": "\u6a5f\u80fd\u8a2d\u8a08\u66f8\u306e\u4f5c\u6210", "status": "completed", "activeForm": "\u6a5f\u80fd\u8a2d\u8a08\u66f8\u3092\u4f5c\u6210\u4e2d"}, {"content": "\u30c7\u30fc\u30bf\u30d9\u30fc\u30b9\u8a2d\u8a08\uff08\u30ef\u30fc\u30af\u30d5\u30ed\u30fc\u95a2\u9023\u30c6\u30fc\u30d6\u30eb\uff09", "status": "completed", "activeForm": "\u30c7\u30fc\u30bf\u30d9\u30fc\u30b9\u8a2d\u8a08\u4e2d"}, {"content": "Prisma\u30b9\u30ad\u30fc\u30de\u4f5c\u6210\uff08\u30ef\u30fc\u30af\u30d5\u30ed\u30fc\u95a2\u9023\u30c6\u30fc\u30d6\u30eb\uff09", "status": "completed", "activeForm": "Prisma\u30b9\u30ad\u30fc\u30de\u3092\u4f5c\u6210\u4e2d"}, {"content": "\u30e6\u30fc\u30b6\u30fc\u8ffd\u52a0\u627f\u8a8d\u30d5\u30ed\u30fc\u8a2d\u8a08", "status": "completed", "activeForm": "\u30e6\u30fc\u30b6\u30fc\u8ffd\u52a0\u627f\u8a8d\u30d5\u30ed\u30fc\u3092\u8a2d\u8a08\u4e2d"}, {"content": "\u6a5f\u80fd\u9593\u9023\u643a\u627f\u8a8d\u30b7\u30b9\u30c6\u30e0\u8a2d\u8a08", "status": "completed", "activeForm": "\u6a5f\u80fd\u9593\u9023\u643a\u627f\u8a8d\u30b7\u30b9\u30c6\u30e0\u3092\u8a2d\u8a08\u4e2d"}, {"content": "\u30d0\u30c3\u30af\u30a8\u30f3\u30c9API\u5b9f\u88c5", "status": "pending", "activeForm": "\u30d0\u30c3\u30af\u30a8\u30f3\u30c9API\u3092\u5b9f\u88c5\u4e2d"}, {"content": "\u30d5\u30ed\u30f3\u30c8\u30a8\u30f3\u30c9\u753b\u9762\u5b9f\u88c5", "status": "pending", "activeForm": "\u30d5\u30ed\u30f3\u30c8\u30a8\u30f3\u30c9\u753b\u9762\u3092\u5b9f\u88c5\u4e2d"}, {"content": "\u5358\u4f53\u8a66\u9a13\u5b9f\u88c5", "status": "pending", "activeForm": "\u5358\u4f53\u8a66\u9a13\u3092\u5b9f\u88c5\u4e2d"}]