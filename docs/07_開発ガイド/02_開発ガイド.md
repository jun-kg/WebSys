# 開発ガイド・プロジェクト移植システム

## 📋 概要

このドキュメントは、**Vue.js + Element Plus + Express + PostgreSQL 共通ライブラリ型システム**の開発・移植・運用のための包括的ガイドです。

### 🎯 共通ライブラリ・企業固有機能分離アーキテクチャ

このプロジェクトは**共通ライブラリ**として他プロジェクトに提供されます。
以下の3層分離により、**共通機能更新時に企業固有機能への影響ゼロ、逆も同様に影響ゼロ**を実現します。

### 📁 ディレクトリ構造の設計原則

```
websys/                           # 共通ライブラリリポジトリ
├── templates/                    # 共通テンプレート（配布用）
│   ├── frontend/src/
│   │   ├── core/                # ✅ 共通コア（変更禁止）
│   │   ├── extensions/          # 🔌 拡張ポイント（カスタマイズ可能）
│   │   └── custom/              # 🏢 企業固有機能（完全独立）
│   └── backend/src/
│       ├── core/                # ✅ 共通コア（変更禁止）
│       ├── extensions/          # 🔌 拡張ポイント（カスタマイズ可能）
│       └── custom/              # 🏢 企業固有機能（完全独立）
```

### 🔐 分離原則と影響範囲

| レイヤー | 変更可否 | 影響範囲 | 用途 | 具体例 |
|---------|---------|---------|------|--------|
| **core/** | ❌ 変更禁止 | 全プロジェクト | 共通基盤機能 | ログ監視・認証・権限管理・RBAC |
| **extensions/** | ✅ 拡張可能 | 個別プロジェクト | 共通機能の拡張 | カスタム認証・追加バリデーション |
| **custom/** | ✅ 自由実装 | 個別プロジェクト | 企業固有ロジック | 営業管理・在庫管理・顧客管理 |

### ✅ このガイドの使用方法

#### 🔄 **既存プロジェクトでの使用**
- 開発規約・ベストプラクティスとして直接適用
- 品質向上・効率化のための参考資料
- **重要**: 既存コードを `core/` に移行する際は影響範囲を十分検証

#### 📦 **新規プロジェクトへの移植**
1. **共通ライブラリ配布**: `templates/` フォルダを新規プロジェクトにコピー
2. **パスエイリアス設定**: vite.config.ts と tsconfig.json を設定
3. **環境構築**: 開発環境セットアップの実行
4. **企業固有機能実装**: `custom/` 内で独自ロジックを実装

#### 🎯 **対象読者**
- Vue.js + Element Plus フロントエンド開発者
- Express.js + Prisma バックエンド開発者
- プロジェクトマネージャー・アーキテクト
- 新規参加開発者・チームリーダー

---

## 🚀 プロジェクト移植チェックリスト

### Phase 1: 基本環境構築（必須）
```yaml
□ Docker環境構築:
  □ Docker 20.10+ インストール済み
  □ Docker Compose 2.0+ インストール済み
  □ Git 2.30+ インストール済み

□ プロジェクト構造作成:
  □ workspace/frontend/ ディレクトリ作成
  □ workspace/backend/ ディレクトリ作成
  □ infrastructure/docker/ ディレクトリ作成

□ 設定ファイル配置:
  □ docker-compose.yml (下記サンプル参照)
  □ .env ファイル (環境変数設定)
  □ package.json (両方のワークスペース)
```

### Phase 2: 技術スタック実装（必須）
```yaml
□ フロントエンド (workspace/frontend/):
  □ Vue.js 3.3+ + TypeScript
  □ Element Plus 2.3+ (自動インポート設定)
  □ Vue Router 4.0+ (SPA ルーティング)
  □ Pinia 2.0+ (状態管理)
  □ Vite 4.0+ (ビルドツール)
  □ パスエイリアス設定 (@core/@extensions/@custom)

□ バックエンド (workspace/backend/):
  □ Express.js 4.18+ + TypeScript
  □ Prisma 5.0+ (ORM・マイグレーション)
  □ JWT認証 (jsonwebtoken)
  □ express-validator (バリデーション)
  □ CORS設定 (クロスオリジン対応)
  □ パスエイリアス設定 (@core/@extensions/@custom)

□ ディレクトリ構造:
  □ src/core/ 作成（共通コアモジュール）
  □ src/extensions/ 作成（拡張ポイント）
  □ src/custom/ 作成（企業固有機能）
  □ README.md 配置（各ディレクトリ）

□ データベース:
  □ PostgreSQL 15+
  □ Prisma Schema設定
  □ 初期マイグレーション実行
```

### Phase 3: 開発規約適用（推奨）
```yaml
□ TypeScript設定:
  □ tsconfig.json (厳密な型チェック設定)
  □ 統一的な型定義規約
  □ インポート順序規約
  □ パスエイリアス設定 (@core/@extensions/@custom)

□ コードスタイル:
  □ ESLint + Prettier設定
  □ 命名規則の統一
  □ コメント・ドキュメント規約
  □ ESLint保護設定 (core/ 変更禁止ルール)

□ Git規約:
  □ ブランチ戦略 (feature/bugfix/hotfix)
  □ コミットメッセージ規約
  □ プルリクエストテンプレート

□ 共通ライブラリ管理:
  □ core/ 更新フロー確立
  □ extensions/ 拡張方法定義
  □ custom/ 実装ガイドライン整備
```

---

## 🔧 移植用環境セットアップテンプレート

### 📋 必須設定ファイル

#### 1. docker-compose.yml (プロジェクトルート)
```yaml
version: '3.8'

services:
  # PostgreSQL データベース
  postgres:
    image: postgres:15
    container_name: ${PROJECT_NAME:-myproject}_postgres
    environment:
      POSTGRES_DB: ${DB_NAME:-myproject_db}
      POSTGRES_USER: ${DB_USER:-admin}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-password}
    ports:
      - "${DB_PORT:-5432}:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - app-network

  # バックエンド API
  backend:
    build:
      context: ./workspace/backend
      dockerfile: Dockerfile
    container_name: ${PROJECT_NAME:-myproject}_backend
    environment:
      NODE_ENV: development
      DATABASE_URL: postgresql://${DB_USER:-admin}:${DB_PASSWORD:-password}@postgres:5432/${DB_NAME:-myproject_db}
      JWT_SECRET: ${JWT_SECRET:-development-secret-key}
      PORT: 8000
    ports:
      - "${BACKEND_PORT:-8000}:8000"
    volumes:
      - ./workspace/backend:/app
      - /app/node_modules
    depends_on:
      - postgres
    networks:
      - app-network
    command: npm run dev

  # フロントエンド SPA
  frontend:
    build:
      context: ./workspace/frontend
      dockerfile: Dockerfile
    container_name: ${PROJECT_NAME:-myproject}_frontend
    environment:
      VITE_API_BASE_URL: http://localhost:${BACKEND_PORT:-8000}
    ports:
      - "${FRONTEND_PORT:-3000}:3000"
    volumes:
      - ./workspace/frontend:/app
      - /app/node_modules
    depends_on:
      - backend
    networks:
      - app-network
    command: npm run dev

volumes:
  postgres_data:

networks:
  app-network:
    driver: bridge
```

#### 2. .env (プロジェクトルート)
```bash
# プロジェクト設定
PROJECT_NAME=myproject

# データベース設定
DB_NAME=myproject_db
DB_USER=admin
DB_PASSWORD=secure-password-here
DB_PORT=5432

# アプリケーション設定
FRONTEND_PORT=3000
BACKEND_PORT=8000
JWT_SECRET=change-this-in-production

# 開発環境設定
NODE_ENV=development
```

#### 3. workspace/backend/Dockerfile
```dockerfile
FROM node:18-alpine

WORKDIR /app

# package.json をコピーして依存関係をインストール
COPY package*.json ./
RUN npm ci

# アプリケーションコードをコピー
COPY . .

# Prisma クライアント生成
RUN npx prisma generate

EXPOSE 8000

CMD ["npm", "run", "dev"]
```

#### 4. workspace/frontend/Dockerfile
```dockerfile
FROM node:18-alpine

WORKDIR /app

# package.json をコピーして依存関係をインストール
COPY package*.json ./
RUN npm ci

# アプリケーションコードをコピー
COPY . .

EXPOSE 3000

CMD ["npm", "run", "dev"]
```

### 🚀 段階別セットアップ手順

#### Step 1: 基本構造作成
```bash
# プロジェクトディレクトリ作成
mkdir my-new-project
cd my-new-project

# 基本ディレクトリ構造作成
mkdir -p workspace/frontend workspace/backend infrastructure/docker

# docs/ フォルダを既存プロジェクトからコピー
cp -r /path/to/source/docs ./

# 設定ファイルを配置
# (上記のテンプレートを各ファイルに保存)
```

#### Step 2: フロントエンド初期化
```bash
cd workspace/frontend

# Vue.js + TypeScript プロジェクト作成
npm create vue@latest . -- --typescript --router --pinia --eslint

# Element Plus インストール
npm install element-plus
npm install -D unplugin-vue-components unplugin-auto-import

# Vite設定更新 (vite.config.ts)
# Element Plus 自動インポート設定追加
```

#### Step 3: バックエンド初期化
```bash
cd workspace/backend

# Node.js + TypeScript プロジェクト初期化
npm init -y
npm install express cors helmet morgan express-validator
npm install jsonwebtoken bcryptjs prisma @prisma/client
npm install -D typescript @types/node @types/express
npm install -D @types/jsonwebtoken @types/bcryptjs nodemon ts-node

# TypeScript設定
npx tsc --init

# Prisma初期化
npx prisma init
```

#### Step 4: データベース・認証セットアップ
```bash
# コンテナ起動
docker-compose up -d postgres

# Prisma マイグレーション実行
cd workspace/backend
npx prisma migrate dev --name init

# 初期データ投入 (オプション)
npx prisma db seed
```

#### Step 5: 開発環境起動・確認
```bash
# 全サービス起動
docker-compose up -d

# アクセス確認
curl http://localhost:3000  # フロントエンド
curl http://localhost:8000/health  # バックエンドAPI

# ログ確認
docker-compose logs -f frontend
docker-compose logs -f backend
```

---

## 📈 標準開発ワークフロー

### 🔄 日常の開発フロー（移植対応）

#### 1. **環境起動・確認**
```bash
# 全サービス起動
docker-compose up -d

# サービス状態確認
docker-compose ps

# ヘルスチェック
curl http://localhost:8000/health  # バックエンドAPI
curl http://localhost:3000         # フロントエンド

# ログ監視 (開発中)
docker-compose logs -f frontend
docker-compose logs -f backend
```

#### 2. **機能開発ブランチ作成**
```bash
# 最新の main ブランチを取得
git checkout main
git pull origin main

# 機能ブランチ作成 (命名規約準拠)
git checkout -b feature/user-authentication
git checkout -b bugfix/login-validation-error
git checkout -b hotfix/security-patch
```

#### 3. **開発作業・ファイル監視**
```bash
# フロントエンド開発 (自動リロード)
cd workspace/frontend
# Vue.js ファイル編集 → ブラウザ自動更新
# TypeScript 型チェック → リアルタイム表示

# バックエンド開発 (自動再起動)
cd workspace/backend
# Express.js ファイル編集 → サーバー自動再起動
# Prisma Schema 変更 → クライアント自動生成
```

#### 4. **データベース操作 (Prisma)**
```bash
# 新しいマイグレーション作成
docker-compose exec backend npx prisma migrate dev --name add_user_profile

# スキーマの直接適用 (開発環境のみ)
docker-compose exec backend npx prisma db push

# データベース管理画面起動
docker-compose exec backend npx prisma studio
# → http://localhost:5555 でアクセス

# Prisma Client 再生成 (スキーマ変更後)
docker-compose exec backend npx prisma generate
```

#### 5. **品質チェック・テスト実行**
```bash
# TypeScript型チェック
cd workspace/frontend && npm run type-check
cd workspace/backend && npm run type-check

# コードフォーマット・リント
cd workspace/frontend && npm run lint:fix
cd workspace/backend && npm run lint:fix

# 単体テスト実行
cd workspace/frontend && npm test
cd workspace/backend && npm test

# E2E テスト実行 (オプション)
npm run test:e2e
```

#### 6. **コミット・プルリクエスト**
```bash
# 変更内容確認
git status
git diff

# ステージング
git add .

# コミット (規約準拠メッセージ)
git commit -m "feat: implement user authentication with JWT"
git commit -m "fix: resolve login validation error"
git commit -m "hotfix: patch SQL injection vulnerability"

# リモートプッシュ
git push origin feature/user-authentication

# プルリクエスト作成 (GitHub/GitLab等)
```

### 🌿 標準ブランチ戦略 (Git Flow)

#### ブランチ構造
```mermaid
gitgraph
    commit id: "Initial"
    branch develop
    commit id: "Dev Setup"

    branch feature/user-auth
    commit id: "Auth Feature"
    checkout develop
    merge feature/user-auth

    branch release/v1.0.0
    commit id: "Release Prep"
    checkout main
    merge release/v1.0.0
    tag: "v1.0.0"

    checkout develop
    merge main

    checkout main
    branch hotfix/security
    commit id: "Security Fix"
    checkout main
    merge hotfix/security
    tag: "v1.0.1"

    checkout develop
    merge main
```

#### 📋 ブランチ命名規則 (必須)
```yaml
基本形式: [type]/[scope]/[description]

主要タイプ:
  - feature/   : 新機能開発
  - bugfix/    : バグ修正
  - hotfix/    : 緊急修正 (本番問題)
  - release/   : リリース準備
  - chore/     : 保守・設定変更
  - docs/      : ドキュメント更新

命名例:
  - feature/auth/jwt-implementation
  - feature/ui/responsive-dashboard
  - bugfix/api/validation-error
  - hotfix/security/sql-injection
  - release/v1.2.0
  - chore/deps/update-packages
  - docs/api/endpoint-documentation
```

#### 🔄 ブランチフロー手順
```bash
# 1. 機能開発開始
git checkout develop
git pull origin develop
git checkout -b feature/auth/jwt-implementation

# 2. 開発・コミット
# ... 開発作業 ...
git commit -m "feat(auth): implement JWT token generation"

# 3. プルリクエスト作成
git push origin feature/auth/jwt-implementation
# → GitHub/GitLab でPR作成

# 4. レビュー・マージ後
git checkout develop
git pull origin develop
git branch -d feature/auth/jwt-implementation

# 5. リリース準備
git checkout -b release/v1.0.0
# ... 最終調整 ...
git checkout main
git merge release/v1.0.0
git tag v1.0.0

# 6. 緊急修正 (ホットフィックス)
git checkout main
git checkout -b hotfix/security/csrf-protection
# ... 修正 ...
git checkout main
git merge hotfix/security/csrf-protection
git tag v1.0.1
```

## 📝 統一コーディング規約

### 🎯 TypeScript/JavaScript 規約

#### 📋 命名規則 (厳格遵守)
```typescript
// ✅ 変数・関数: camelCase (推奨)
const userName = 'john_doe'
const getCurrentUser = () => {}
const calculateTotalAmount = (items: Item[]) => {}

// ✅ 定数: UPPER_SNAKE_CASE (必須)
const API_BASE_URL = 'http://localhost:8000'
const MAX_RETRY_ATTEMPTS = 3
const DEFAULT_PAGE_SIZE = 20

// ✅ クラス・インターface・型: PascalCase (必須)
class UserService {}
interface UserData {}
type ResponseStatus = 'success' | 'error' | 'pending'

// ✅ ファイル・ディレクトリ名: kebab-case (必須)
user-management.vue
api-client.ts
user-profile/
auth-middleware/

// ✅ コンポーネント名: PascalCase (Vue.js)
UserProfile.vue
LoginForm.vue
NavigationMenu.vue

// ❌ 使用禁止パターン
const user_name = 'bad'      // snake_case
const GETDATA = () => {}     // 全大文字
interface userData {}       // camelCase interface
class userService {}        // camelCase class
```

#### 🔧 TypeScript 型定義規約
```typescript
// ✅ 推奨: 明示的・具体的な型定義
interface User {
  id: number
  username: string
  email: string
  role: UserRole
  isActive: boolean
  createdAt: Date
  updatedAt: Date
}

// ✅ Enum定義 (明確な値指定)
enum UserRole {
  ADMIN = 'ADMIN',
  USER = 'USER',
  GUEST = 'GUEST'
}

// ✅ Union型 (型安全な選択肢)
type ResponseStatus = 'loading' | 'success' | 'error'
type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE'

// ✅ Generic型 (再利用可能な型)
interface ApiResponse<T> {
  success: boolean
  data: T
  message?: string
  errors?: string[]
}

// ✅ 関数型定義 (引数・戻り値明記)
type UserValidator = (user: Partial<User>) => Promise<ValidationResult>
type EventHandler<T> = (event: T) => void

// ✅ Props定義 (Vue.js - withDefaults使用)
interface Props {
  user: User
  isEditable?: boolean
  onSave?: (user: User) => void
}

const props = withDefaults(defineProps<Props>(), {
  isEditable: false,
  onSave: undefined
})

// ❌ 避けるべきパターン
const data: any = {}           // any 型の多用
interface Props {              // オプション型の乱用
  value?: string | undefined
}
```

#### 📦 Import/Export 順序規約 (必須遵守・共通ライブラリ対応)
```typescript
// ✅ 標準的な Import 順序（3層分離対応）
// 1. Node.js 標準ライブラリ
import fs from 'fs'
import path from 'path'
import { createHash } from 'crypto'

// 2. 外部ライブラリ (node_modules)
import express, { Request, Response } from 'express'
import { PrismaClient } from '@prisma/client'
import jwt from 'jsonwebtoken'
import bcrypt from 'bcryptjs'

// 3. 共通コアモジュール (変更禁止・@core エイリアス必須)
import { prisma } from '@core/lib/prisma'
import { authenticate, authorize } from '@core/middleware/auth'
import { LogController } from '@core/controllers/LogController'
import type { User, UserRole } from '@core/types/user'

// 4. 拡張モジュール (カスタマイズ可能・@extensions エイリアス)
import { customAuthMiddleware } from '@extensions/middleware/customAuth'
import { ValidationService } from '@extensions/services/validation'

// 5. 企業固有モジュール (自由実装・@custom エイリアス)
import { SalesReportService } from '@custom/services/SalesReportService'
import { InventoryController } from '@custom/controllers/InventoryController'
import type { SalesData } from '@custom/types/sales'

// 6. 相対インポート (同一ディレクトリ・親ディレクトリ)
import { UserService } from './services/user'
import { validateInput } from '../utils/validation'
import type { LocalConfig } from './types'

// ✅ Export パターン
// Named Export (推奨 - tree shaking対応)
export const userService = new UserService()
export const createUser = async (data: CreateUserData) => {}
export type { User, UserRole }

// Default Export (コンポーネント・メインクラスのみ)
export default class AuthService {}

// ❌ 避けるべきパターン
import * as everything from 'library'  // 全体インポート
export * from './module'               // 全体エクスポート
import { prisma } from '../core/lib/prisma'  // ❌ 相対パス禁止（@core使用）
import { CustomService } from '../../custom/services/CustomService'  // ❌ (@custom使用)
```

#### 🏗️ ファイル構造規約
```typescript
// ✅ 標準ファイル構造テンプレート

// === バックエンド API ファイル ===
/*
1. Import statements
2. Type definitions
3. Constants
4. Middleware functions
5. Route handlers
6. Export statements
*/

// === フロントエンド Vue Component ===
/*
<template>
  <!-- HTML template -->
</template>

<script setup lang="ts">
// 1. Imports
// 2. Props & Emits
// 3. Reactive data
// 4. Computed properties
// 5. Methods
// 6. Lifecycle hooks
// 7. Watchers
</script>

<style scoped>
/* Component-specific styles */
</style>
*/

// === TypeScript Service Class ===
/*
1. Imports
2. Types/Interfaces
3. Constants
4. Class definition
   - Properties
   - Constructor
   - Public methods
   - Private methods
5. Export
*/
```

### 🎨 Vue.js 3 + Element Plus 規約

#### 📋 標準コンポーネント構造 (必須テンプレート)
```vue
<template>
  <!-- ✅ Element Plus コンポーネント使用 -->
  <el-card class="user-profile-card">
    <template #header>
      <div class="card-header">
        <span>{{ title }}</span>
        <el-button v-if="isEditable" type="primary" @click="handleSave">
          保存
        </el-button>
      </div>
    </template>

    <!-- ✅ 条件付きレンダリング -->
    <el-form v-if="user" ref="formRef" :model="formData" :rules="rules">
      <el-form-item label="ユーザー名" prop="username">
        <el-input v-model="formData.username" :disabled="!isEditable" />
      </el-form-item>
    </el-form>

    <!-- ✅ ローディング・エラー状態 -->
    <el-skeleton v-else :loading="isLoading" animated>
      <template #template>
        <el-skeleton-item variant="text" style="width: 100%" />
      </template>
    </el-skeleton>
  </el-card>
</template>

<script setup lang="ts">
// ✅ 標準的な構造順序 (必須)
// 1. Imports
import { ref, computed, onMounted, watch } from 'vue'
import type { FormInstance, FormRules } from 'element-plus'
import { ElMessage } from 'element-plus'
import type { User } from '@/types/user'

// 2. Props定義 (型安全・デフォルト値)
interface Props {
  user: User | null
  isEditable?: boolean
  title?: string
}

const props = withDefaults(defineProps<Props>(), {
  isEditable: false,
  title: 'ユーザープロフィール'
})

// 3. Emits定義 (型安全なイベント)
interface Emits {
  (e: 'update:user', user: User): void
  (e: 'save', data: Partial<User>): void
  (e: 'delete', id: number): void
}

const emit = defineEmits<Emits>()

// 4. Reactive Data (ref/reactive)
const formRef = ref<FormInstance>()
const isLoading = ref(false)
const formData = ref<Partial<User>>({
  username: '',
  email: ''
})

// 5. Computed Properties
const isFormValid = computed(() => {
  return formData.value.username && formData.value.email
})

const displayName = computed(() => {
  return props.user?.username || 'Unknown User'
})

// 6. Methods (async/await パターン)
const handleSave = async () => {
  if (!formRef.value) return

  try {
    const isValid = await formRef.value.validate()
    if (!isValid) return

    isLoading.value = true
    emit('save', formData.value)
    ElMessage.success('保存しました')
  } catch (error) {
    ElMessage.error('保存に失敗しました')
    console.error('Save error:', error)
  } finally {
    isLoading.value = false
  }
}

const resetForm = () => {
  formRef.value?.resetFields()
}

// 7. Lifecycle Hooks
onMounted(() => {
  if (props.user) {
    formData.value = { ...props.user }
  }
})

// 8. Watchers
watch(
  () => props.user,
  (newUser) => {
    if (newUser) {
      formData.value = { ...newUser }
    }
  },
  { deep: true }
)

// 9. Form Validation Rules
const rules: FormRules = {
  username: [
    { required: true, message: 'ユーザー名は必須です', trigger: 'blur' },
    { min: 3, max: 20, message: '3-20文字で入力してください', trigger: 'blur' }
  ],
  email: [
    { required: true, message: 'メールアドレスは必須です', trigger: 'blur' },
    { type: 'email', message: '有効なメールアドレスを入力してください', trigger: 'blur' }
  ]
}
</script>

<style scoped>
/* ✅ BEMスタイル命名規約 */
.user-profile-card {
  margin: 20px;
  box-shadow: var(--el-box-shadow-light);
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

/* ✅ レスポンシブ対応 */
@media (max-width: 768px) {
  .user-profile-card {
    margin: 10px;
  }

  .card-header {
    flex-direction: column;
    gap: 10px;
  }
}

/* ✅ アクセシビリティ対応 */
.user-profile-card:focus-within {
  outline: 2px solid var(--el-color-primary);
  outline-offset: 2px;
}
</style>
```

#### 🔧 Element Plus 統合規約
```typescript
// ✅ 自動インポート設定 (vite.config.ts)
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'

export default defineConfig({
  plugins: [
    vue(),
    AutoImport({
      resolvers: [ElementPlusResolver()],
      imports: ['vue', 'vue-router', 'pinia']
    }),
    Components({
      resolvers: [ElementPlusResolver()],
    }),
  ],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src')
    }
  }
})

// ✅ テーマカスタマイズ (main.ts)
import 'element-plus/theme-chalk/dark/css-vars.css'
import '@/styles/element-plus-custom.scss'

// ✅ 国際化設定
import { createApp } from 'vue'
import ElementPlus from 'element-plus'
import jaJP from 'element-plus/es/locale/lang/ja'

const app = createApp(App)
app.use(ElementPlus, { locale: jaJP })
```

### 🚀 Express.js + Prisma 規約

#### 📋 RESTful API 設計規約 (移植テンプレート)
```typescript
// ✅ 標準的なRESTful API設計
GET    /api/users              // ユーザー一覧取得 (ページネーション対応)
POST   /api/users              // ユーザー作成
GET    /api/users/:id          // ユーザー詳細取得
PUT    /api/users/:id          // ユーザー完全更新
PATCH  /api/users/:id          // ユーザー部分更新
DELETE /api/users/:id          // ユーザー削除

// ✅ 認証・認可API
POST   /api/auth/login         // ログイン
POST   /api/auth/logout        // ログアウト
POST   /api/auth/refresh       // トークンリフレッシュ
GET    /api/auth/me            // 現在ユーザー情報取得

// ✅ ヘルスチェック・管理API
GET    /health                 // サービス稼働確認
GET    /api/health             // API稼働確認
GET    /api/version            // バージョン情報

// ✅ 検索・フィルタリング対応
GET    /api/users?page=1&limit=20&search=john&role=ADMIN
GET    /api/users?sort=createdAt:desc&filter=isActive:true
```

#### 🔧 標準APIエンドポイント実装テンプレート
```typescript
// ✅ users.ts (完全なAPI実装例)
import express, { Request, Response, NextFunction } from 'express'
import { body, query, param, validationResult } from 'express-validator'
import { prisma } from '../lib/prisma'  // 必須: 統一Prismaインスタンス
import { authenticate, authorize } from '../middleware/auth'
import type { User, UserRole } from '@prisma/client'

const router = express.Router()

// ✅ 統一レスポンス型定義 (必須)
interface ApiResponse<T = any> {
  success: boolean
  data?: T
  message?: string
  errors?: string[]
  pagination?: {
    page: number
    limit: number
    total: number
    totalPages: number
  }
}

// ✅ 統一エラーレスポンス型 (必須実装)
interface StandardErrorResponse {
  success: false
  error: {
    code: string          // エラーコード（例: USER_NOT_FOUND）
    message: string       // ユーザー向けメッセージ
    details?: any         // 詳細情報（開発環境のみ）
    timestamp: string     // エラー発生時刻
    requestId: string     // リクエスト追跡ID
  }
}

// ✅ バリデーション規則
const createUserValidation = [
  body('username')
    .isLength({ min: 3, max: 20 })
    .withMessage('ユーザー名は3-20文字で入力してください')
    .matches(/^[a-zA-Z0-9_]+$/)
    .withMessage('ユーザー名は英数字とアンダースコアのみ使用可能です'),
  body('email')
    .isEmail()
    .withMessage('有効なメールアドレスを入力してください')
    .normalizeEmail(),
  body('password')
    .isLength({ min: 8 })
    .withMessage('パスワードは8文字以上で入力してください')
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
    .withMessage('パスワードは大文字・小文字・数字を含む必要があります'),
  body('role')
    .optional()
    .isIn(['ADMIN', 'USER', 'GUEST'])
    .withMessage('有効な権限を指定してください')
]

const getUsersValidation = [
  query('page')
    .optional()
    .isInt({ min: 1 })
    .withMessage('ページ番号は1以上の整数で指定してください'),
  query('limit')
    .optional()
    .isInt({ min: 1, max: 100 })
    .withMessage('取得件数は1-100の範囲で指定してください'),
  query('search')
    .optional()
    .isLength({ max: 100 })
    .withMessage('検索文字列は100文字以内で入力してください'),
  query('role')
    .optional()
    .isIn(['ADMIN', 'USER', 'GUEST'])
    .withMessage('有効な権限を指定してください')
]

// ✅ ユーザー一覧取得 (ページネーション・検索対応)
router.get('/',
  authenticate,
  getUsersValidation,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const page = parseInt(req.query.page as string) || 1
      const limit = parseInt(req.query.limit as string) || 20
      const search = req.query.search as string
      const role = req.query.role as UserRole
      const offset = (page - 1) * limit

      // 検索条件構築
      const where: any = {}
      if (search) {
        where.OR = [
          { username: { contains: search, mode: 'insensitive' } },
          { email: { contains: search, mode: 'insensitive' } }
        ]
      }
      if (role) {
        where.role = role
      }

      // データ取得 (並列実行で効率化)
      const [users, total] = await Promise.all([
        prisma.user.findMany({
          where,
          select: {
            id: true,
            username: true,
            email: true,
            role: true,
            isActive: true,
            createdAt: true,
            updatedAt: true
            // password は含めない (セキュリティ)
          },
          orderBy: { createdAt: 'desc' },
          take: limit,
          skip: offset
        }),
        prisma.user.count({ where })
      ])

      const response: ApiResponse<User[]> = {
        success: true,
        data: users,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit)
        }
      }

      res.json(response)
    } catch (error) {
      next(error)
    }
  }
)

// ✅ ユーザー作成
router.post('/',
  authenticate,
  authorize(['ADMIN']),  // 管理者のみ
  createUserValidation,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        const response: ApiResponse = {
          success: false,
          message: 'バリデーションエラーが発生しました',
          errors: errors.array().map(err => err.msg)
        }
        return res.status(400).json(response)
      }

      const { username, email, password, role = 'USER' } = req.body

      // 重複チェック
      const existingUser = await prisma.user.findFirst({
        where: {
          OR: [
            { username },
            { email }
          ]
        }
      })

      if (existingUser) {
        const response: ApiResponse = {
          success: false,
          message: 'ユーザー名またはメールアドレスが既に使用されています'
        }
        return res.status(409).json(response)
      }

      // パスワードハッシュ化
      const bcrypt = require('bcryptjs')
      const hashedPassword = await bcrypt.hash(password, 12)

      // ユーザー作成
      const user = await prisma.user.create({
        data: {
          username,
          email,
          password: hashedPassword,
          role,
          isActive: true
        },
        select: {
          id: true,
          username: true,
          email: true,
          role: true,
          isActive: true,
          createdAt: true,
          updatedAt: true
        }
      })

      const response: ApiResponse<User> = {
        success: true,
        data: user,
        message: 'ユーザーを作成しました'
      }

      res.status(201).json(response)
    } catch (error) {
      next(error)
    }
  }
)

// ✅ エクスポート
export default router
```

#### 標準エラーハンドリング（必須実装）
```typescript
// 統一エラーレスポンス（全プロジェクト共通）
interface StandardErrorResponse {
  success: false
  error: {
    code: string          // エラーコード（例: USER_NOT_FOUND）
    message: string       // ユーザー向けメッセージ
    details?: any         // 詳細情報（開発環境のみ）
    timestamp: string     // エラー発生時刻
    requestId: string     // リクエスト追跡ID
  }
}

// 標準エラーミドルウェア（必須実装）
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  const requestId = req.headers['x-request-id'] || Math.random().toString(36)

  const response: StandardErrorResponse = {
    success: false,
    error: {
      code: err.name || 'INTERNAL_ERROR',
      message: err.message,
      timestamp: new Date().toISOString(),
      requestId: requestId as string
    }
  }

  // 開発環境でのみスタックトレース追加
  if (process.env.NODE_ENV === 'development') {
    response.error.details = { stack: err.stack }
  }

  // ログ出力（本番環境監視用）
  console.error(`[${requestId}] ${err.name}: ${err.message}`, {
    stack: err.stack,
    url: req.url,
    method: req.method,
    ip: req.ip
  })

  res.status(err.statusCode || 500).json(response)
})
```

#### バリデーション
```typescript
import { body, validationResult } from 'express-validator'

// バリデーションルール
export const createUserValidation = [
  body('username')
    .isLength({ min: 3, max: 20 })
    .withMessage('ユーザー名は3-20文字で入力してください'),
  body('email')
    .isEmail()
    .withMessage('有効なメールアドレスを入力してください'),
  body('password')
    .isLength({ min: 6 })
    .withMessage('パスワードは6文字以上で入力してください')
]

// バリデーション処理
export const handleValidation = (req: Request, res: Response, next: NextFunction) => {
  const errors = validationResult(req)
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() })
  }
  next()
}
```

## データベース規約

### Prisma Schema
```prisma
// モデル定義
model User {
  id        Int      @id @default(autoincrement())
  username  String   @unique
  email     String   @unique
  password  String
  name      String
  role      UserRole @default(USER)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users") // テーブル名をスネークケース
}

// Enum定義
enum UserRole {
  ADMIN
  USER
  GUEST
}
```

### マイグレーション
```bash
# マイグレーション作成
npx prisma migrate dev --name add_user_table

# マイグレーション適用
npx prisma migrate deploy

# スキーマリセット（開発環境のみ）
npx prisma migrate reset
```

## テスト戦略

### フロントエンド テスト
```typescript
// Unit Test (Vitest)
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import UserCard from '@/components/UserCard.vue'

describe('UserCard', () => {
  it('displays user information correctly', () => {
    const user = { id: 1, name: 'John Doe', email: 'john@example.com' }
    const wrapper = mount(UserCard, { props: { user } })

    expect(wrapper.text()).toContain('John Doe')
    expect(wrapper.text()).toContain('john@example.com')
  })
})

// E2E Test (Playwright)
import { test, expect } from '@playwright/test'

test('user login flow', async ({ page }) => {
  await page.goto('http://localhost:3000/login')
  await page.fill('[data-testid="username"]', 'admin')
  await page.fill('[data-testid="password"]', 'password')
  await page.click('[data-testid="login-button"]')
  await expect(page).toHaveURL('/dashboard')
})
```

### バックエンド テスト
```typescript
// Unit Test (Jest)
import { UserService } from '../services/user'
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()
const userService = new UserService(prisma)

describe('UserService', () => {
  it('creates user successfully', async () => {
    const userData = {
      username: 'testuser',
      email: 'test@example.com',
      password: 'password123',
      name: 'Test User'
    }

    const user = await userService.createUser(userData)
    expect(user.username).toBe('testuser')
    expect(user.email).toBe('test@example.com')
  })
})

// Integration Test
import request from 'supertest'
import app from '../app'

describe('POST /api/users', () => {
  it('creates user with valid data', async () => {
    const response = await request(app)
      .post('/api/users')
      .send({
        username: 'newuser',
        email: 'new@example.com',
        password: 'password123',
        name: 'New User'
      })
      .expect(201)

    expect(response.body.username).toBe('newuser')
  })
})
```

## パフォーマンス最適化

### フロントエンド最適化

#### コード分割
```typescript
// ルートレベルコード分割
const Dashboard = () => import('@/views/Dashboard.vue')
const Users = () => import('@/views/Users.vue')

const routes = [
  { path: '/dashboard', component: Dashboard },
  { path: '/users', component: Users }
]
```

#### 状態管理最適化
```typescript
// Pinia Store
export const useUserStore = defineStore('user', () => {
  const users = ref<User[]>([])
  const loading = ref(false)

  // Computed (自動キャッシュ)
  const activeUsers = computed(() =>
    users.value.filter(user => user.isActive)
  )

  // Actions
  const fetchUsers = async () => {
    if (loading.value) return // 重複リクエスト防止

    loading.value = true
    try {
      const response = await api.get('/users')
      users.value = response.data
    } finally {
      loading.value = false
    }
  }

  return { users, loading, activeUsers, fetchUsers }
})
```

### バックエンド最適化

#### データベースクエリ最適化
```typescript
// 効率的なクエリ
const getUsersWithPosts = await prisma.user.findMany({
  select: {
    id: true,
    username: true,
    email: true,
    _count: {
      select: { posts: true }
    }
  },
  where: {
    isActive: true
  },
  orderBy: {
    createdAt: 'desc'
  },
  take: 20,
  skip: offset
})

// N+1問題の回避
const usersWithPosts = await prisma.user.findMany({
  include: {
    posts: {
      take: 5,
      orderBy: { createdAt: 'desc' }
    }
  }
})
```

#### キャッシュ戦略
```typescript
// メモリキャッシュ
const cache = new Map<string, any>()

const getCachedUser = async (id: number): Promise<User> => {
  const cacheKey = `user:${id}`

  if (cache.has(cacheKey)) {
    return cache.get(cacheKey)
  }

  const user = await prisma.user.findUnique({ where: { id } })
  cache.set(cacheKey, user)

  return user
}
```

## セキュリティベストプラクティス

### 認証・認可
```typescript
// JWT実装
const generateToken = (user: User): string => {
  return jwt.sign(
    { userId: user.id, username: user.username, role: user.role },
    process.env.JWT_SECRET!,
    { expiresIn: '7d' }
  )
}

// 認証ミドルウェア
const authenticate = (req: Request, res: Response, next: NextFunction) => {
  const token = req.header('Authorization')?.replace('Bearer ', '')

  if (!token) {
    return res.status(401).json({ message: '認証が必要です' })
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET!)
    req.user = decoded
    next()
  } catch (error) {
    res.status(401).json({ message: '無効なトークンです' })
  }
}
```

### データバリデーション
```typescript
// 入力サニタイゼーション
import validator from 'validator'

const sanitizeInput = (input: string): string => {
  return validator.escape(validator.trim(input))
}

// SQL Injection防止（Prisma）
const getUserById = async (id: number) => {
  // Prismaは自動的にパラメータをエスケープ
  return await prisma.user.findUnique({
    where: { id } // 安全
  })
}
```

## デプロイ準備

### 環境変数管理
```bash
# development
NODE_ENV=development
DATABASE_URL=postgresql://admin:password@postgres:5432/websys_db_dev
JWT_SECRET=dev-secret-key

# production
NODE_ENV=production
DATABASE_URL=postgresql://admin:secure-password@db.example.com:5432/websys_db_prod
JWT_SECRET=production-secure-secret-key
```

### ビルド最適化
```typescript
// vite.config.ts (production)
export default defineConfig({
  build: {
    minify: 'terser',
    rollupOptions: {
      output: {
        chunkFileNames: 'assets/[name]-[hash].js',
        entryFileNames: 'assets/[name]-[hash].js',
        assetFileNames: 'assets/[name]-[hash].[ext]'
      }
    }
  }
})
```

## 継続的インテグレーション

### GitHub Actions例
```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          cd workspace/frontend && npm ci
          cd workspace/backend && npm ci

      - name: Run tests
        run: |
          cd workspace/frontend && npm run test
          cd workspace/backend && npm run test

      - name: Build
        run: |
          cd workspace/frontend && npm run build
          cd workspace/backend && npm run build
```

---

## 🎯 プロジェクト移植完了チェックリスト

### 📋 Phase 1: 基本環境構築
```yaml
□ 環境要件:
  □ Docker 20.10+ 確認済み
  □ Docker Compose 2.0+ 確認済み
  □ Git 2.30+ 確認済み
  □ Node.js 18+ 確認済み (オプション)

□ プロジェクト構造:
  □ workspace/frontend/ 作成完了
  □ workspace/backend/ 作成完了
  □ docs/ フォルダコピー完了
  □ docker-compose.yml 配置完了
  □ .env ファイル設定完了

□ 基本動作確認:
  □ docker-compose up -d 成功
  □ http://localhost:3000 アクセス可能
  □ http://localhost:8000/health アクセス可能
  □ PostgreSQL 接続成功
```

### 📋 Phase 2: フロントエンド実装
```yaml
□ Vue.js基盤:
  □ Vue.js 3.3+ + TypeScript インストール完了
  □ Vue Router 4.0+ 設定完了
  □ Pinia 2.0+ 状態管理設定完了
  □ Vite 4.0+ ビルド設定完了

□ Element Plus統合:
  □ Element Plus 2.3+ インストール完了
  □ 自動インポート設定 (unplugin-vue-components)
  □ 日本語ロケール設定完了
  □ カスタムテーマ設定完了

□ 開発環境:
  □ TypeScript厳格モード有効化
  □ ESLint + Prettier 設定完了
  □ ホットリロード動作確認
  □ 型チェック自動実行確認
```

### 📋 Phase 3: バックエンド実装
```yaml
□ Express.js基盤:
  □ Express.js 4.18+ + TypeScript インストール完了
  □ CORS・セキュリティ設定完了
  □ 環境変数管理設定完了
  □ ログ出力設定完了

□ Prisma ORM:
  □ Prisma 5.0+ インストール完了
  □ schema.prisma 設定完了
  □ 初期マイグレーション実行完了
  □ Prisma Client 生成完了
  □ 統一Prismaインスタンス設定完了

□ 認証・認可:
  □ JWT認証ミドルウェア実装完了
  □ ユーザー認証API実装完了
  □ RBAC権限管理実装完了
  □ セキュリティ設定完了
```

### 📋 Phase 4: API実装・動作確認
```yaml
□ 基本CRUD API:
  □ ユーザー管理API実装完了
  □ 認証API実装完了
  □ バリデーション実装完了
  □ エラーハンドリング実装完了
  □ ページネーション実装完了

□ 動作確認:
  □ 全APIエンドポイント動作確認
  □ フロントエンド⇔バックエンド通信確認
  □ データベース操作確認
  □ 認証フロー動作確認
  □ エラーハンドリング動作確認
```

### 📋 Phase 5: 品質・セキュリティ確認
```yaml
□ コード品質:
  □ TypeScript型チェック合格
  □ ESLint検証合格
  □ Prettier整形適用済み
  □ コーディング規約準拠確認

□ セキュリティ:
  □ パスワードハッシュ化確認
  □ JWT署名・検証確認
  □ CORS適切設定確認
  □ SQL Injection対策確認
  □ XSS対策確認

□ テスト:
  □ 単体テスト実行成功
  □ 統合テスト実行成功
  □ E2Eテスト実行成功 (オプション)
  □ 負荷テスト実行成功 (オプション)
```

---

## 🏆 移植完了判定基準

### ✅ 最小要件 (必須)
1. **基本機能動作**: 認証・CRUD・画面表示の正常動作
2. **コード品質**: TypeScript型チェック・ESLint検証合格
3. **セキュリティ**: 基本的なセキュリティ設定完了
4. **ドキュメント**: 開発ガイド・API仕様書完備

### ⭐ 推奨要件 (高品質)
1. **テスト**: 単体・統合テスト80%以上のカバレッジ
2. **パフォーマンス**: ページ読み込み3秒以内
3. **アクセシビリティ**: WCAG AA準拠
4. **レスポンシブ**: 全デバイス対応

### 🚀 発展要件 (エンタープライズ)
1. **監視**: ログ監視・アラート設定
2. **CI/CD**: 自動テスト・デプロイ設定
3. **国際化**: 多言語対応
4. **拡張性**: マイクロサービス対応準備

---

## 📞 移植支援・トラブルシューティング

### 🆘 よくある問題と解決方法

#### 🔧 Docker関連
```bash
# コンテナ起動失敗
docker-compose down && docker-compose up -d --force-recreate

# ボリューム削除
docker-compose down -v && docker-compose up -d

# ログ確認
docker-compose logs -f [service-name]
```

#### 🔧 Prisma関連
```bash
# スキーマ同期エラー
npx prisma db push --force-reset

# マイグレーション失敗
npx prisma migrate reset && npx prisma migrate dev

# クライアント生成エラー
npx prisma generate
```

#### 🔧 Node.js関連
```bash
# 依存関係エラー
rm -rf node_modules package-lock.json && npm install

# TypeScript型エラー
npm run type-check

# ビルドエラー
npm run build
```

### 📧 技術支援連絡先
- **GitHub Issues**: プロジェクトリポジトリのIssues
- **ドキュメント**: docs/フォルダ内の各種ガイド
- **API仕様**: docs/03_機能/01_API仕様書.md参照

---

**🎉 移植成功おめでとうございます！**

このガイドに従って実装することで、**企業グレードの高品質Webアプリケーション**が完成します。

**継続的改善**: 定期的にドキュメントを更新し、チーム全体で品質向上に努めてください。

---

*移植ガイド更新日: 2025-10-01*
*対応技術スタック: Vue.js 3.3+ / Element Plus 2.3+ / Express.js 4.18+ / Prisma 5.0+ / PostgreSQL 15+*
*品質レベル: エンタープライズグレード*